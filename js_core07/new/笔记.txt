1、错误处理：当程序发生错误时，保证程序不会异常中断的机制
     为什么：程序默认只要碰到错误就会闪退，用户体验感差！
   如何错误处理：
	try{
	    //可能发生错误的代码段
	}catch(err){
	    //只有错误发生的时候，才会执行的代码段
	}finally{
	    //无论是否发生异常，都会执行的代码段
	}
	其实finally可以省略

   强调：err会在错误发生时，自动获得一个错误对象
	 错误对象：封装错误信息的对象，在发生错误的时候自动创建
	 ***JS错误对象的类型：6种
	    1、语法错误：SyntaxError - 可能是符号错误
	    2、引用错误：ReferenceError - 没有创建的东西，你直接使用了
	    3、类型错误：TypeError - 不是你的，你却用了
	    4、范围错误：RangeError - 范围超过了

	       EvalError、URIError - 我们不可能遇到

	 性能：放在try中的代码，效率都会降低
	       解决：1、尽量在try中只放可能出错的代码
		     2、大多数异常，都可以提前预知并且防范，但是需要经验累积
			大多数异常，都可以if提前判断错误
	 

***只要是客户端输入的就有可能出现错误，一切的客户端都当做坏人！！！
   比如：1、恶意输入 - isNaN()
	 2、toFixed() - range 0 ~ 100
	 3、用正则

   try...catch中的鄙视题：

	function f1(){
		
	}
	try catch中的return
	    1、finally中没有return
		如果不出错，首先确定try中的return的结果
		  在执行finally中的代码
	 	  最后返回结果
	        如果出错了，首先指定catch中的代码
	          确定catch中的return的结果
		  在执行finally中的代码
	 	  最后返回结果
	        finally中的代码不会影响返回的结果
	    2、finally中有return，finally中的return会覆盖之前所有的return

   抛出自定义异常：
	何时：自己创建了一个函数，提醒调用者，错误的使用了函数
	throw new Error("自定义的错误信息");
	只要是错误就会卡主后续代码

上午的练习：1、使用try...catch...解决toFixed带来的错误，但是就算错了，后续代码也要执行
            2、使用if...else...完成上述任务
	    3、昨天的PPT31页 2题（try..catch和if..else版）;

2、*****Function：
   js中一切的东西都是对象，函数名都是引用函数对象的地址值的变量
   创建函数：3种
   1、*声明方式：function 函数名(形参列表){函数体; return 返回值;}
      只有声明方式创建的函数才能完整的声明提前
   2、函数直接量：
      var 函数名=function(形参列表){函数体; return 返回值;}
   3、new构造函数方式：
      var 函数名=new Function("形参1","形参2"...,"函数体 return 返回值");
      强调：无论参数实际是什么类型
	    都要用""包裹！

      鄙视时：js中正确的创建函数的方法：3个

   *****重载（overload）：相同函数名，不同参数列表的多个函数
	可在调用时，根据传入的参数的不同，
	自动选择对应的函数执行！
        为什么：减少调用者的负担！
	问题：js的语法不支持重载！
	      js不允许多个同名函数同时存在
	      如果同时存在，最后定义的函数会覆盖之前所有的同名函数

	解决：在函数中自带一个对象，arguments对象
        什么是arguments对象：函数中，专门接受所有传入的实参的对象
	  arguments对象是类数组对象，长的像数组的对象
		只有两点和数组相同：
			1、都可用下标访问每个元素
			   比如：获得第四个实参：arguments[3]
			2、都有length属性记录参数个数
			   比如：arguments.length
		何时创建：在调用函数时，自动创建

	  可以做的事儿：变相的实现了重载

   *****匿名函数：创建函数，不适用任何变量引用的函数，说白了就是没有函数名的函数
	何时使用：如果函数，只会执行一次！
	为什么：节约内存
		因为匿名函数对象，某有变量引用着
	        用完，立刻释放
	如何使用：2种
	  1、自调：函数定义完，立刻执行！
	//类似于全局中的代码，仅执行一次，打开页面立刻执行，所有的内容都会自动释放
		(function(){
			console.log(1);
		})();

	  2、***回调：将函数作为参数，传递给其他函数调用！
	     arr.sort(function(a,b){return a-b});
	     str.replace(reg,function(a){return "要替换的内容"});
	  因为后续回调函数会越来越多，而且等我们学了ES6箭头函数过后，
	  回调函数的长相会发生很大的变化

作业：1、第六天PPT  31页 2题
      2、第六天PPT  36页 1、2题
      3、第七天PPT  9页 1题（页面上生成表格），最低要求，保证二维数组能够排序
-----------------------------------------------------------------------------------
      4、金夫人，下周3交


十一个引用类型的对象：String Number（num.toFixed(d)） Boolean
 	       Array Date Math RegExp
	       Error
	       *Function *Object
	       Global - window代替了它，是全局对象