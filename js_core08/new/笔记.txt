1、继承：父对象的成员（属性和方法），子对象可以直接使用
   面向对象三大特点：封装 继承 多态
   为什么继承：代码重用！节约内存空间！
   何时继承：只要多个子对象公用的属性和方法，都要集中定义在父对象（原型）中

   什么是原型：保存一类子对象共有属性和共有方法的父对象
		所有子对象都自动继承自对应的原型对象
   	       注意：只要创建出一个对象浏览器都自动设置了继承
		     str 继承自 string的原型
		     arr 继承自 array的原型
		     date 继承自 date的原型
		     obj 继承自 object的原型
		所有对象的顶层都是 object的原型

   如何获得原型（父对象/祖先对象）：
	1、构造函数.prototype;
	2、对象.__proto__;

   获得原型就可以在原型上添加共有属性和共有方法！
	原型对象.属性名=属性值;
	原型对象.方法名=function(){}

  
  可以通过__proto__逐级访问每一层原型，最顶就是Object的原型，形成的一条链式结构称之为  原型链，对象成员的访问规则：
	1、现在对象本地找自有属性
	2、如果自己没有，就通过__proto__找到原型对象的共有属性

    自有属性和共有属性
	自有：保存在对象本地的
	共有：保存在原型对象中的

    鄙视题：判断自有属性和共有属性
	1、判断自有属性：obj.hasOwnProperty("属性名");
	   如果返回的是true，说明"属性名"是obj的自有属性
	   如果返回的是false，说明"属性名"不是obj的自有属性，有两种可能：共有或者没有
	2、判断共有属性：2个条件
		1、不是自有：obj.hasOwnProperty("属性名")==false
		2、在原型链上查找："属性名" in 对象
		if(wsc.hasOwnProperty("属性名")==false && "属性名" in wsc){
			console.log("共有");
		}else{
			console.log("没有");
		}

   修改或删除属性：
	1、修改或删除自有属性
	   修改：obj.属性名=新值;
	   删除：delete obj.属性名;
	2、修改或删除共有属性
	   不能直接对象子对象操作
	   必须找到对应的原型对象的
	   如果直接对子对象做操作
		1、修改：obj.共有属性=新值;
		   结果：在obj本地添加了同名的自有属性，覆盖了共有属性
		2、删除：delete obj.共有属性 -- 无效

   解决浏览器的兼容性问题！！！
   特殊：老IE没有以下两个方法，我需要为老IE添加
   1、indexOf();
	if(Array.prototype.indexOf===undefined){
		Array.prototype.indexOf=function(){
			//方法的原理
			//注意由于我创建的方法希望每个数组都能使用，所以里面用this指			//当前调用函数的数组
		}
	}

   2、trim();

上午的练习：
  1、练习：是用构造函数方式创建多个对象，并且找到原型，为原型添加共有属性和共有方法！
  2、为老IE添加以上两个方法。

***********************************************************************************

  获得一个对象的原型对象
	Object.getPrototype(obj) == obj.__proto__

  检查对象之间是否存在继承关系
	父对象.isPrototypeOf(子对象)
	判断父对象是否是子对象的父级
	强调：isPrototypeOf不但可以检查直接父级，还可以检查所有原型链上的父级

  鄙视题：*****判断一个对象是不是数组：请4种方法
	  typeof无法区分对象和数组，返回都是object
	1、判断当前对象是否继承自Array.prototype
		Array.prototype.isPrototypeOf(arr);
	2、arr instanceof Array
	   判断 arr 是否是构造函数创建的
	3、输出对象的字符串形式：
	   在Object的原型中保存着是最原始的toString()
	   原始的toString：默认输出[object Object]
	***多态（重写）：子对象觉得父对象的成员不好用，可以在本地定义同名的成员，覆盖			 	父对象中的成员
	   借用函数：Object.prototype.toString.apply(arr);
	4、Array.isArray(arr);

  *****实现自定义继承：
	1、实现两个对象之间的继承：
	   子对象.__proto__=父对象;

	2、实现多个对象之间的继承：
	   构造函数.prototype=父对象;
	   时机：必须在开始创建对象之前就设置继承

作业：
  1、为数组添加indexOf,为字符串添加trim方法，要求老IE（678）兼容
  2、判断一个对象是不是数组！4种方法
  3、使用面向对象（封装、继承）：选项卡 和 轮播
***********************************************************************************
  4、这周的思维导图！